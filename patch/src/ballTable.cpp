#include "wog2/misc.h"
#include "wog2/environment.h"
#include "wog2/templateInfo.h"
#include "ballTable.h"
#include "log.h"

extern "C" {

enum class ReadLineResult {
    SUCCESS,
    EMPTY_LINE,
    ERROR,
};

bool createBallTable(Storage* storage);
void loadBallTable(Storage* storage);
static ReadLineResult readLine(const char* inputFile, int& i, int fileSize,
        int& out_ballId, int& out_contentLen, const char*& out_content);
static void fixBallTable(Storage* storage, const char* inputFile, int fileSize, int lineNumber);
static char skipSpaces(const char* inputFile, int& i, int fileSize);
static int readWord(const char* inputFile, int& i, int fileSize, const char*& result);

#define BASE_GOOBALL_COUNT 39

const char ballTablePath[] = "fisty/ballTable.ini";

const char ballTableHeader[] =
    "; This table defines all Gooball typeEnums\n"
    "; Extend this list to add your own gooballs.\n"
    "; \n"
    "; Generated by FistyLoader 1.1\n\n";

void initBallTable() {
    FileSystemUtils_CreateDir("fisty");
    
    Environment* environment = Environment_instance();
    Storage* storage = environment->getStorage();
    
#ifdef ENABLE_LOGGING
    FileHandle handle;
    storage->FileOpen("log.txt", 0x22, &handle);
    initPrint(storage, handle);
#endif
    
    if (storage->FileExists(ballTablePath)) {
        loadBallTable(storage);
    } else {
        customGooballIds = gooballIds;
        gooballCount = BASE_GOOBALL_COUNT;
        
        bool success = createBallTable(storage);
        
        if (success) {
            SDL_ShowSimpleMessageBox(0x40, "Fisty Loader",
                "Successfully extracted assets from exe file into 'World of Goo 2 "
                "(current installation's game directory)/game/fisty'", 0);
        }
    }
}

bool createBallTable(Storage* storage) {
    FileHandle handle;
    bool result = storage->FileOpen(ballTablePath, 0x22, &handle); // 0x22 = "w+b"
    
    if (result != 0) {
        // TODO: Error message kind of outdated with the steam release
        SDL_ShowSimpleMessageBox(0x40, "Fisty Loader",
            "Failed to create ballTable.ini file. Make sure the game directory is not "
            "inside C:\\Program Files or any other place that requires administrator permissions.\n\n"
            "Continuing with default settings.", 0);
        
        return false;
    }
    
    storage->FileWrite(handle, ballTableHeader, sizeof(ballTableHeader) - 1);
    
    for (int i = 0; i < BASE_GOOBALL_COUNT; i++) {
        char buffer[0x80];
        int size = snprintf(buffer, sizeof(buffer), "%d=%s\n", i, gooballIds[i]);
        storage->FileWrite(handle, buffer, size);
    }
    
    storage->FileClose(handle);
    return true;
}

void loadBallTable(Storage* storage) {
    // read file content
    FileHandle handle;
    storage->FileOpen(ballTablePath, 0x11, &handle); // 0x11 = "rb"
    
    int fileSize = storage->FileGetSize(handle);
    char* inputFile = (char*)malloc(fileSize + 1);
    
    storage->FileRead(handle, inputFile, fileSize);
    // add null terminator
    inputFile[fileSize] = 0;
    
    storage->FileClose(handle);
    
    // storage->FileOpen("log2.txt", 0x22, &handle); // 0x11 = "rb"
    // initPrint(storage, handle);
    
    // parse ini content
    int maxGooballId = -1;
    int stringBufSize = 0;
    int lineNumber = 0;
    
    // count max gooball id and value string buffer size
    for (int i = 0; i < fileSize; i++) {
        lineNumber += 1;
        
        int ballId;
        int contentLen;
        const char* content;
        
        switch (readLine(inputFile, i, fileSize, ballId, contentLen, content)) {
            case ReadLineResult::EMPTY_LINE:
                continue;
            case ReadLineResult::ERROR:
                fixBallTable(storage, inputFile, fileSize, lineNumber);
                return;
        }
        
        if (ballId > maxGooballId)
            maxGooballId = ballId;
        
        if (contentLen != 0) {
            stringBufSize += contentLen + 1;
        }
    }
    
    if (maxGooballId == 0) {
        fixBallTable(storage, inputFile, fileSize, 1);
        return;
    }
    
    int gooballIdCount = maxGooballId + 1;
    
    // allocate buffer
    int gooballIdsBufSize = gooballIdCount * 8 + 8;
    char* buffer = (char*)malloc(gooballIdsBufSize + stringBufSize);
    
    const char** gooballIds = (const char**)buffer;
    char* stringBuf = &buffer[gooballIdsBufSize];
    
    // fill gooballIds with empty strings
    for (int i = 0; i < gooballIdCount; i++) {
        gooballIds[i] = "";
    }
    
    gooballIds[gooballIdCount] = 0;
    
    // populate gooballIds and stringBuf
    for (int i = 0; i < fileSize; i++) {
        int ballId;
        int contentLen;
        const char* content;
        
        if (readLine(inputFile, i, fileSize, ballId, contentLen, content) == ReadLineResult::EMPTY_LINE) {
            continue;
        }
        
        if (contentLen == 0)
            continue;
        
        strncpy(stringBuf, content, contentLen);
        stringBuf[contentLen] = 0;
        
        gooballIds[ballId] = stringBuf;
        stringBuf += contentLen + 1;
    }
    
    customGooballIds = gooballIds;
    gooballCount = gooballIdCount;
    
    free(inputFile);
}

static void fixBallTable(Storage* storage, const char* inputFile, int fileSize, int lineNumber) {
    char buffer[0x110];
    snprintf(buffer, sizeof(buffer),
        "Error reading ballTable.ini in line %d.\n"
        "Copying current ballTable file to 'ballTable_backup.ini'\n"
        "and regenerating ballTable.\n"
        "Continuing with default settings.", lineNumber);
    
    SDL_ShowSimpleMessageBox(0x10, "Fisty Loader", buffer, 0);
    
    // Backup ballTable into ballTable_backup.ini and regenerate
    FileHandle handle;
    int result = storage->FileOpen("fisty/ballTable_backup.ini", 0x22, &handle); // 0x22 = "w+b"
    
    if (result == 0) {
        storage->FileWrite(handle, inputFile, fileSize);
        storage->FileClose(handle);
        
        createBallTable(storage);
    } else {
        // Failure to back up ballTable
        SDL_ShowSimpleMessageBox(0x10, "Fisty Loader",
            "Failed to create ballTable_backup.ini.\n"
            "ballTable.ini will not be modified.\n"
            "If you wish to still have it be regenerated,\n"
            "delete the file and start the game again.\n"
            "Continuing with default settings.", 0);
    }
    
    // Load default values
    customGooballIds = gooballIds;
    gooballCount = BASE_GOOBALL_COUNT;
}

// Reads one line of ballTable.ini until it encounters an equals sign (=)
// and parses the left hand side into an integer if it does.
// 
// After this function is done, `i` will point to the '\n' character
// at the end of the line.
static ReadLineResult readLine(const char* inputFile, int& i, int fileSize,
        int& out_ballId, int& out_contentLen, const char*& out_content) {
    
    // Read lhs
    const char* lhsStart;
    int lhsLength = readWord(inputFile, i, fileSize, lhsStart);
    
    // Skip ahead until '=' sign
    switch (skipSpaces(inputFile, i, fileSize)) {
        case '\n':
            if (lhsLength == 0)
                return ReadLineResult::EMPTY_LINE;
            else
                return ReadLineResult::ERROR;
        case '=':
            i++;
            break;
        default:
            return ReadLineResult::ERROR;
    }
    
    // Read rhs
    int rhsLength = readWord(inputFile, i, fileSize, out_content);
    
    // Skip ahead until newline
    switch (skipSpaces(inputFile, i, fileSize)) {
        case '\n':
        case '\0':
            break;
        default:
            return ReadLineResult::ERROR;
    }

    // Parse lhs into integer
    set_errno(0);
    char* str_end;
    int lhs = strtol(lhsStart, &str_end, 10);
    
    int errno;
    get_errno(&errno);
    if (errno != 0) {
        return ReadLineResult::ERROR;
    }
    
    // Make sure it read the correct amount of characters and the number is not negative
    int charsRead = str_end - lhsStart;
    if (charsRead != lhsLength || lhs < 0) {
        return ReadLineResult::ERROR;
    }
    
    out_ballId = lhs;
    out_contentLen = rhsLength;
    return ReadLineResult::SUCCESS;
}

// Advances `i` until it no longer points to a space ('\n' not included) and returns that
// character.
// When it hits a ';', it will skip everything until the end of line.
static char skipSpaces(const char* inputFile, int& i, int fileSize) {
    for (; i < fileSize; i++) {
        switch (inputFile[i]) {
            case ';':
                for (; i < fileSize && inputFile[i] != '\n'; i++) {}
                // fall through
            case '\n':
            case '=':
                return inputFile[i];
        }
        
        if (!isspace(inputFile[i])) {
            return inputFile[i];
        }
    }
    
    return '\0';
}

static int readWord(const char* inputFile, int& i, int fileSize, const char*& result) {
    result = nullptr;
    
    // skip initial whitespace
    for (; i < fileSize; i++) {
        if (inputFile[i] == '\n' || !isspace(inputFile[i]))
            break;
    }
    
    result = &inputFile[i];
    int length = 0;
    
    // increment length until special character or space is hit
    for (; i < fileSize; i++) {
        char c = inputFile[i];
        
        switch (c) {
            case ';':
            case '=':
            case '\n':
                return length;
        }
        
        if (isspace(c))
            return length;
        
        length++;
    }
    
    return length;
}

}
